---
title: "Getting Started"
author: "Connor H Knight"
date: "11/08/2021"
output: 
    html_document:
    toc: true
    toc_depth: 3
    theme: united
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# Analysing 2994 Bone Marrow Mononuclear Cells (BMMC) from a single sample.

To demonstrate IBRAP we enlisted a sample produced by [Oetjen](https://insight.jci.org/articles/view/124928) *et al*. This can be downloaded using the following link:  

https://www.dropbox.com/sh/f2hhztiyzo04yt9/AACeK5nZBcQ7Fnz02hgF6GG5a?dl=0

## Initiating the IBRAP S4 object

Since our datasets are produced by 10x genomics and aligned using CellRanger, 3 subsequent files are produced to integrate these files into a count matrix.

```

bmmc <- Read10X_output(directory = '~Downloads/marrow_A', 
                       matrix.file = 'matrix.mtx', 
                       genes.file = 'genes.tsv', 
                       barcodes.file = 'barcodes.tsv')
                       
```

Droplet-based technologies are normally accompanied by specific conundra that requires omission, namely: multiplets and ambient RNA. With IBRAP you can apply a python package called scrublet (perform.scrublet()) and decontX (perform.decontX()) from the celda package in R for removal, respectively. We supply our count matrix to the functions. There is no defined order of applciation, but logically we assume scrublet removal followed by decontX. 

```

# We simply supply our generated count matrix to both functions
bmmc <- perform.scrublet(counts = bmmc)

bmmc <- perform.decontX(counts = bmmc)

```
Now we can initiate our IBRAP class object ready for downstream analyses. Refer to methods-object and IBRAP-object for further detail. 

```

# whilst creating the object we begin filtering the cells and genes using min.cells and min.features
bmmc <- createIBRAPobject(counts = bmmc,
                          original.project = 'bmmc',
                          method.name = 'RAW',
                          min.cells = 3,
                          min.features = 200)
                          
```

## Quality Control

Current best practices for quality assuring scRNA-seq datasets are outlined in numerous [publications](https://www.embopress.org/doi/full/10.15252/msb.20188746). Including:

```{r table2, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
df <- data.frame(`QC Metric` = c('Mitochondrial Fraction', 'Total RNA', 'Total Genes'), Description = c('An abnormally high mitochondrail fraction indicates improper wet lab preparation', 'Low RNA quanitity indicates droplets containing no cells whereas, disproportionately high RNA indicates a droplet containing more than one cell', 'likewise, a low or high number of genes typically correspond with total RNA'))

knitr::kable(df)
```

The total RNA and Total genes are calculated upon the creation of the IBRAP object. However, percentage mitochondrial genes requires a second function since mitochondrial genes have a varying prefix in datasets. Thus, we use find_percentage_genes():

```

bmmc <- find_percentage_genes(object = celseq2, pattern = '^MT-',
                              assay = 'RAW', 
                              slot = 'counts',
                              column.name = 'RAW_percent.mt')
                              
```

We can visualise this information in two ways: using violin plots (plot.qc.vln()) or comparing two metrices with scatter plots (plot.qc.scatter()). The latter enables us to observe correlations between the metrices. 

```

plot.QC.vln(object = celseq2, 
            metadata.columns = c('RAW_total.features', 
                                 'RAW_total.counts', 
                                 'RAW_percent.mt'))
                                 
```

Filtration is subsequently applied to remove problematic cells.

```

bmmc <- filter_IBRAP(RAW_total.features < 2500 & RAW_total.counts > 200 & RAW_percent.mt < 8)

```

## Data Transformation

To accommodate downstream analyses, we must promote a normal distribution and numerical scaling in our data.







