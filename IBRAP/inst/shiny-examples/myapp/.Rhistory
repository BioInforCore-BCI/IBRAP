if (multi.method==TRUE) {
return(multi.object)
} else {
return(object)
}
}
# find_HVGs <- function(object, norm.method, block = NULL, design = NULL,
#                       subset.row = NULL, subset.fit = NULL, equiweight = TRUE,
#                       method = "fisher", BPPARAM = SerialParam(), ...) {
#   if(norm.method == 'scran') {
#     dec <- modelGeneVar(assay(object, 'data'), block = block, design = design,
#     subset.row = subset.row, subset.fit = subset.fit, equiweight = TRUE,
#     method = "fisher", BPPARAM = SerialParam())
#     top.hvg <- do.call('getTopHVGs', list(dec, ...))
#     object <- object[top.hvg,]
#   }
#   if(norm.method == 'linnorm') {
#
#   }
#   if(norm.method == 'other') {
#     clusters <- quickCluster(assay(object, 'data'))
#     sg = sortGenes(assay(object, 'data'), clusters)
#     pp=getPValues(sg)
#     features <- names(which(apply(pp$adjpval, 1, function(x) any(x < 0.05))))
#     object <- object[features,]
#   }
#   return(object)
# }
# perform_SC3 <- function(object, n.clusters='estimate') {
#   rowData(object)$feature_symbol <- rownames(object)
#   if(n.clusters == 'estimate'){
#     tmp <- sc3_estimate_k(object)@metadata$sc3$k_estimation
#     object <- sc3(object, ks = tmp, biology = FALSE)
#   } else {
#     object <- sc3(object, ks = n.clusters, biology = FALSE)
#   }
#   return(object)
# }
performUMAP <- function(object) {
c <- uwot::umap(X = reducedDim(object, 'pca'), verbose = TRUE)
colnames(c) <- c('umap_1', 'umap_2')
reducedDim(object, 'umap') <- c
return(object)
}
plot_dr <- function(object, reduction) {
tmp <- as.data.frame(colData(object))
tmp$`Cell Barcodes` <- colnames(object)
if(reduction == 'umap') {
a <- as.data.frame(reducedDim(df, 'umap'))
colnames(a) <- c('UMAP 1', 'UMAP 2')
tmp <- as.data.frame(c(tmp, a))
clust.column <- names[grepl('clusters', x = names)]
clust.info <- colData(object)[,clust.column]
tmp$cluster <- clust.info
myColors <- brewer.pal(length(unique(tmp$cluster)),"Set3")
names(myColors) <- levels(clust.column)
colScale <- scale_colour_manual(name = "Cluster",values = myColors)
p <- ggplot(data = tmp, aes(ident = `Cell.Barcodes`, x = `UMAP.1`, y = `UMAP.2`, percent.mt = percent.mt, colour = cluster)) + geom_point()
p1 <- p + colScale
h <- ggplotly(p1)
}
return(h)
}
# output$umap <- renderPlotly({
#   req(initiate.umap())
#   decision <- input$subcluster_mode
#   if(decision == TRUE) {
#     df <- forout_reactive$subset.1
#   } else {
#     df <- forout_reactive$umap
#   }
#   method <- as.character(input$nldrm)
#   tmp <- as.data.frame(colData(df))
#   tmp$`Cell Barcodes` <- colnames(df)
#   print('step 1')
#   rd <- reducedDimNames(df)
#   if('umap' %in% rd) {
#     a <- as.data.frame(reducedDim(df, 'umap'))
#     colnames(a) <- c('UMAP_1', 'UMAP_2')
#     tmp <- as.data.frame(c(tmp, a))
#     print('step 2')
#     clust.column <- names(tmp[grepl('_clusters', x = names(tmp))])
#     print('step 2.1')
#     cluster <- tmp[,clust.column]
#     print('step 2.2')
#     tmp$cluster <- cluster
#     print('step 3')
#     colourCount = length(unique(cluster))
#     getPalette = colorRampPalette(brewer.pal(9, "Set1"))
#     print('step 4')
#     plot <- ggplot(data = tmp, aes(ident = `Cell.Barcodes`, x = `UMAP_1`, y = `UMAP_2`, percent.mt = percent.mt, color = cluster)) +
#       geom_point(shape = 16, size = 1.5) +
#       scale_color_hue() +
#       guides(fill=FALSE, alpha=FALSE, size=FALSE) +
#       theme_minimal() +
#       theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))
#   }
#   if('tsne' %in% rd) {
#     a <- as.data.frame(reducedDim(df, 'tsne'))
#     colnames(a) <- c('tSNE_1', 'tSNE_2')
#     tmp <- as.data.frame(c(tmp, a))
#     print('step 2')
#     clust.column <- names(tmp[grepl('_clusters', x = names(tmp))])
#     print('step 2.1')
#     cluster <- tmp[,clust.column]
#     print('step 2.2')
#     tmp$cluster <- cluster
#     print('step 3')
#     colourCount = length(unique(cluster))
#     getPalette = colorRampPalette(brewer.pal(9, "Set1"))
#     print('step 4')
#     plot <- ggplot(data = tmp, aes(ident = `Cell.Barcodes`, x = `tSNE_1`, y = `UtSNE_2`, percent.mt = percent.mt, color = cluster)) +
#       geom_point(shape = 16, size = 1.5, alpha = 0.9) +
#       scale_color_hue() +
#       guides(fill=FALSE, alpha=FALSE, size=FALSE) +
#       theme_minimal() +
#       theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))
#   }
#   print('step 5')
#   z <- ggplotly(a, height = 800, width = 1200)
#   print('step 6')
#   z
# })
system2("which", "python3")
Sys.setenv(PATH = paste(c("/usr/local/bin", Sys.getenv("PATH")),
collapse = .Platform$path.sep))
reticulate::use_python(python = '/usr/bin/python3')
reticulate::py_config()
scrub <- import('scrublet')
scrub <- reticulate::import('scrublet')
library(IBRAP)
scrublet <- function(matrix) {
if(is.matrix(matrix) == FALSE) {
cat(crayon::cyan('Only an object of class Matrix can be used'))
} else {
#scrub <- reticulate::import('scrublet')
cat(crayon::cyan('scrublet loaded'))
raw_counts <- t(matrix)
scrub1 <- scrub$Scrublet(counts_matrix = raw_counts, expected_doublet_rate = 0.075)
cat(crayon::cyan('scrublet object created'))
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
cat(crayon::cyan('doublets detected'))
raw_counts <- t(as.data.frame(raw_counts))
raw_counts <- raw_counts[,!res1[[2]] == TRUE]
storage.mode(raw_counts) <- 'integer'
cat(crayon::cyan('matrix scrubbed'))
return(raw_counts)
rm(obj, raw_counts, scrub1, res1, scrubbed)
}
}
marrow <- Read10X_output('/Users/knight05/Raw_Data/Database_samples/healthy_references/BMMC_atlas/marrow_L')
t <- scrublet(matrix = marrow)
library(celda)
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
d <- decontX(matrix)
pdf(paste0(i, '/QC/contamination_umap.pdf'))
p <- plotDecontXContamination(d)
print(p)
dev.off()
clean.matrix <- d$decontXcounts
mode(clean.matrix) <- 'integer'
return(clean.matrix)
}
d <- decontaminate(t)
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
d <- decontX(matrix)
print(plotDecontXContamination(d))
clean.matrix <- d$decontXcounts
mode(clean.matrix) <- 'integer'
return(clean.matrix)
}
d <- decontaminate(t)
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
d <- decontX(matrix)
#print(plotDecontXContamination(d))
clean.matrix <- d$decontXcounts
mode(clean.matrix) <- 'integer'
return(clean.matrix)
}
d <- decontaminate(t)
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
d <- decontX(matrix)
#print(plotDecontXContamination(d))
#clean.matrix <- d$decontXcounts
#mode(clean.matrix) <- 'integer'
return(d)
}
d <- decontaminate(t)
t
d
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
d <- decontX(matrix)
#print(plotDecontXContamination(d))
clean.matrix <- d$decontXcounts
mode(clean.matrix) <- 'integer'
return(clean.matrix)
}
d <- decontaminate(t)
d
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
d <- decontX(matrix)
#print(plotDecontXContamination(d))
clean.matrix <- d$decontXcounts
mode(clean.matrix) <- 'integer'
return(d)
}
d <- decontaminate(t)
d
scrublet <- function(matrix) {
if(is.matrix(matrix) == FALSE) {
cat(crayon::cyan('Only an object of class Matrix can be used\n'))
} else {
raw_counts <- t(matrix)
scrub1 <- scrub$Scrublet(counts_matrix = raw_counts, expected_doublet_rate = 0.075)
cat(crayon::cyan('scrublet object created\n'))
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
cat(crayon::cyan('doublets detected\n'))
raw_counts <- t(as.data.frame(raw_counts))
raw_counts <- raw_counts[,!res1[[2]] == TRUE]
storage.mode(raw_counts) <- 'integer'
cat(crayon::cyan('matrix scrubbed\n'))
return(raw_counts)
rm(obj, raw_counts, scrub1, res1, scrubbed)
}
}
clean.data <- function(matrix) {
tmp <- scrublet(matrix = matrix)
tmp <- decontaminate(matrix = tmp)
return(tmp)
}
scrub$Scrublet
scrublet <- function(matrix, total_counts = NULL, sim_doublet_ratio = 2.0, n_neighbors = NULL, expected_doublet_rate = 0.075, random_state = 0L) {
if(is.matrix(matrix) == FALSE) {
cat(crayon::cyan('Only an object of class Matrix can be used\n'))
} else {
raw_counts <- t(matrix)
scrub1 <- scrub$Scrublet(counts_matrix = raw_counts,
total_counts = total_counts,
sim_doublet_ratio = sim_doublet_ratio,
n_neighbors = n_neighbours,
expected_doublet_rate = expected_doublet_rate,
stdev_doublet_rate = stdev_doublet_rate,
random_state = random_state)
cat(crayon::cyan('scrublet object created\n'))
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
cat(crayon::cyan('doublets detected\n'))
raw_counts <- t(as.data.frame(raw_counts))
raw_counts <- raw_counts[,!res1[[2]] == TRUE]
storage.mode(raw_counts) <- 'integer'
cat(crayon::cyan('matrix scrubbed\n'))
return(raw_counts)
rm(obj, raw_counts, scrub1, res1, scrubbed)
}
}
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
cat(crayon::cyan('Uninformative features omitted\n'))
d <- decontX(matrix)
cat(crayon::cyan('Decontamination comlpleted\n'))
print(plotDecontXContamination(d))
clean.matrix <- d$decontXcounts
cat(crayon::cyan('Matrix isolated\n'))
mode(clean.matrix) <- 'integer'
cat(crayon::cyan('Converting to integer\n'))
return(clean.matrix)
cat(crayon::cyan('Finished\n'))
}
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
cat(crayon::cyan('Uninformative features omitted\n'))
d <- decontX(matrix)
cat(crayon::cyan('Decontamination comlpleted\n'))
print(plotDecontXContamination(d))
clean.matrix <- d$decontXcounts
cat(crayon::cyan('Matrix isolated\n'))
mode(clean.matrix) <- 'integer'
cat(crayon::cyan('Converting to integer\n'))
return(clean.matrix)
cat(crayon::cyan('Finished\n'))
}
clean.data <- function(matrix, matrix, total_counts = NULL, sim_doublet_ratio = 2.0, n_neighbors = NULL, expected_doublet_rate = 0.075, random_state = 0L) {
tmp <- scrublet(matrix = matrix,
total_counts = total_counts,
sim_doublet_ratio = sim_doublet_ratio,
n_neighbors = n_neighbours,
expected_doublet_rate = expected_doublet_rate,
stdev_doublet_rate = stdev_doublet_rate,
random_state = random_state)
tmp <- decontaminate(matrix = tmp)
return(tmp)
}
clean.data <- function(matrix, total_counts = NULL, sim_doublet_ratio = 2.0, n_neighbors = NULL, expected_doublet_rate = 0.075, random_state = 0L) {
tmp <- scrublet(matrix = matrix,
total_counts = total_counts,
sim_doublet_ratio = sim_doublet_ratio,
n_neighbors = n_neighbours,
expected_doublet_rate = expected_doublet_rate,
stdev_doublet_rate = stdev_doublet_rate,
random_state = random_state)
tmp <- decontaminate(matrix = tmp)
return(tmp)
}
# reads 10x data files
tmp <- Read10X_output('/Users/knight05/Raw_Data/Database_samples/healthy_references/BMMC_atlas/marrow_L')
scrublet <- function(matrix, total_counts = NULL, sim_doublet_ratio = 2.0, n_neighbors = NULL, expected_doublet_rate = 0.075, random_state = 0L) {
if(is.matrix(matrix) == FALSE) {
cat(crayon::cyan('Only an object of class Matrix can be used\n'))
} else {
raw_counts <- t(matrix)
scrub1 <- scrub$Scrublet(counts_matrix = raw_counts,
total_counts = total_counts,
sim_doublet_ratio = sim_doublet_ratio,
n_neighbors = n_neighbours,
expected_doublet_rate = expected_doublet_rate,
stdev_doublet_rate = stdev_doublet_rate,
random_state = random_state)
cat(crayon::cyan('scrublet object created\n'))
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
cat(crayon::cyan('doublets detected\n'))
raw_counts <- t(as.data.frame(raw_counts))
raw_counts <- raw_counts[,!res1[[2]] == TRUE]
storage.mode(raw_counts) <- 'integer'
cat(crayon::cyan('matrix scrubbed\n'))
return(res1)
rm(obj, raw_counts, scrub1, res1, scrubbed)
}
}
t <- scrublet(matrix = marrow)
scrublet <- function(matrix, total_counts = NULL, sim_doublet_ratio = 2.0, n_neighbors = NULL, expected_doublet_rate = 0.075, random_state = 0L) {
if(is.matrix(matrix) == FALSE) {
cat(crayon::cyan('Only an object of class Matrix can be used\n'))
} else {
raw_counts <- t(matrix)
scrub1 <- scrub$Scrublet(counts_matrix = raw_counts,
total_counts = total_counts,
sim_doublet_ratio = sim_doublet_ratio,
n_neighbors = n_neighbors,
expected_doublet_rate = expected_doublet_rate,
stdev_doublet_rate = stdev_doublet_rate,
random_state = random_state)
cat(crayon::cyan('scrublet object created\n'))
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
cat(crayon::cyan('doublets detected\n'))
raw_counts <- t(as.data.frame(raw_counts))
raw_counts <- raw_counts[,!res1[[2]] == TRUE]
storage.mode(raw_counts) <- 'integer'
cat(crayon::cyan('matrix scrubbed\n'))
return(raw_counts)
rm(obj, raw_counts, scrub1, res1, scrubbed)
}
}
t <- scrublet(matrix = marrow)
scrublet <- function(matrix, total_counts = NULL, sim_doublet_ratio = 2.0, n_neighbors = NULL, expected_doublet_rate = 0.075, stdev_doublet_rate = 0.02, random_state = 0L) {
if(is.matrix(matrix) == FALSE) {
cat(crayon::cyan('Only an object of class Matrix can be used\n'))
} else {
raw_counts <- t(matrix)
scrub1 <- scrub$Scrublet(counts_matrix = raw_counts,
total_counts = total_counts,
sim_doublet_ratio = sim_doublet_ratio,
n_neighbors = n_neighbors,
expected_doublet_rate = expected_doublet_rate,
stdev_doublet_rate = stdev_doublet_rate,
random_state = random_state)
cat(crayon::cyan('scrublet object created\n'))
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
cat(crayon::cyan('doublets detected\n'))
raw_counts <- t(as.data.frame(raw_counts))
# show the percentage of doublets in sample.
frac <- length(res1[[2]] == TRUE)/length(colnames)
cat(crayon::cyan('doublet fraction: ', frac, '\n'))
raw_counts <- raw_counts[,!res1[[2]] == TRUE]
storage.mode(raw_counts) <- 'integer'
cat(crayon::cyan('matrix scrubbed\n'))
return(raw_counts)
rm(obj, raw_counts, scrub1, res1, scrubbed)
}
}
t <- scrublet(matrix = marrow)
scrublet <- function(matrix, total_counts = NULL, sim_doublet_ratio = 2.0, n_neighbors = NULL, expected_doublet_rate = 0.075, stdev_doublet_rate = 0.02, random_state = 0L) {
if(is.matrix(matrix) == FALSE) {
cat(crayon::cyan('Only an object of class Matrix can be used\n'))
} else {
raw_counts <- t(matrix)
scrub1 <- scrub$Scrublet(counts_matrix = raw_counts)
cat(crayon::cyan('scrublet object created\n'))
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
cat(crayon::cyan('doublets detected\n'))
raw_counts <- t(as.data.frame(raw_counts))
# show the percentage of doublets in sample.
frac <- length(res1[[2]] == TRUE)/length(colnames)
cat(crayon::cyan('doublet fraction: ', frac, '\n'))
raw_counts <- raw_counts[,!res1[[2]] == TRUE]
storage.mode(raw_counts) <- 'integer'
cat(crayon::cyan('matrix scrubbed\n'))
return(raw_counts)
rm(obj, raw_counts, scrub1, res1, scrubbed)
}
}
t <- scrublet(matrix = marrow)
library(reticulate)
py_config()
scrub <- import('scrublet')
# reads 10x data files
tmp <- Read10X_output('/Users/knight05/Raw_Data/Database_samples/healthy_references/BMMC_atlas/marrow_L')
library(IBRAP)
library(celda)
# reads 10x data files
tmp <- Read10X_output('/Users/knight05/Raw_Data/Database_samples/healthy_references/BMMC_atlas/marrow_L')
decontaminate <- function(matrix) {
matrix <- matrix[names(which(rowSums(matrix) > 0)),]
cat(crayon::cyan('Uninformative features omitted\n'))
d <- decontX(matrix)
cat(crayon::cyan('Decontamination comlpleted\n'))
print(plotDecontXContamination(d))
clean.matrix <- d$decontXcounts
cat(crayon::cyan('Matrix isolated\n'))
mode(clean.matrix) <- 'integer'
cat(crayon::cyan('Converting to integer\n'))
return(clean.matrix)
cat(crayon::cyan('Finished\n'))
}
scrublet <- function(matrix, total_counts = NULL, sim_doublet_ratio = 2.0, n_neighbors = NULL, expected_doublet_rate = 0.075, stdev_doublet_rate = 0.02, random_state = 0L) {
if(is.matrix(matrix) == FALSE) {
cat(crayon::cyan('Only an object of class Matrix can be used\n'))
} else {
raw_counts <- t(matrix)
scrub1 <- scrub$Scrublet(counts_matrix = raw_counts)
cat(crayon::cyan('scrublet object created\n'))
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
cat(crayon::cyan('doublets detected\n'))
raw_counts <- t(as.data.frame(raw_counts))
# show the percentage of doublets in sample.
frac <- length(res1[[2]] == TRUE)/length(colnames)
cat(crayon::cyan('doublet fraction: ', frac, '\n'))
raw_counts <- raw_counts[,!res1[[2]] == TRUE]
storage.mode(raw_counts) <- 'integer'
cat(crayon::cyan('matrix scrubbed\n'))
return(raw_counts)
rm(obj, raw_counts, scrub1, res1, scrubbed)
}
}
tmp <- scrublet(matrix = tmp)
tmp
scrub1 <- scrub$Scrublet(counts_matrix = marrow)
# reads 10x data files
tmp <- Read10X_output('/Users/knight05/Raw_Data/Database_samples/healthy_references/BMMC_atlas/marrow_L')
scrub1 <- scrub$Scrublet(counts_matrix = tmp)
res1 <- scrub1$scrub_doublets(min_counts = 3, min_cells = 1, min_gene_variability_pctl = 85)
scrub1$plot_histogram
scrub1$plot_histogram()
mltp$show()
mltp <- import('matplotlib.pyplot')
mltp$show()
dim(tmp)
tmp1 <- scrublet(matrix = tmp)
dim(tmp1)
dim(tmp)
tmp2 <- decontaminate(matrix = tmp1)
dim(tmp2)
dim(tmp1)
ls()
setwd('/Users/knight05/Raw_Data/Database_samples/BloodCancerAtlas/Roider_FL_DLBCL/dataverse_files')
files <- ls()
files
files <- system('ls')
files
files <- list.files('.')
files
files <- files[c(-1,-2,-10,-14)]
files
library(Seurat)
for(n in files) {
samp.list[[n]] <- Read10X(data.dir = n)
}
samp.list <- list()
for(n in files) {
samp.list[[n]] <- Read10X(data.dir = n)
}
samp.list
for(n in files) {
samp.list[[n]] <- dim(samp.list[[n]])
}
samp.list
for(n in files) {
samp.list[[n]] <- Read10X(data.dir = n)
}
prop.list <- list()
for(n in files) {
prop.list[[n]] <- dim(samp.list[[n]])[2]
}
prop.list
unlist(prop.list, recursive = TRUE)
a <- unlist(prop.list, recursive = TRUE)
class(a)
a <- as.data.frame(a)
a
colnames(a) <- 'n.cells'
a
getwd()
setwd('~')
write.csv(x = a, file = 'tmp.csv')
IBRAP::Run_IBRAP_clustering_browser()
shiny::runApp()
setwd("~/Results/scRNA-seq/Apps/IBRAP/Versions/IBRAP/inst/shiny-examples/myapp")
shiny::runApp()
