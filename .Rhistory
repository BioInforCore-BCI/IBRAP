cat(crayon::cyan('Latent.vars must be character(s)\n'))
return(NULL)
} else if(!latent.vars %in% names(object@sample_metadata)) {
cat(crayon::cyan('Latent.vars do not exist in object@sample_metadata \n'))
return(NULL)
}
seuobj <- Seurat::CreateSeuratObject(counts = object@methods[[assay]]@counts)
seuobj@assays$RNA@data <- object@methods[[assay]]@normalised
seuobj@assays$RNA@scale.data <- object@methods[[assay]]@norm.scaled
seuobj$cluster <- identity
Seurat::Idents(seuobj) <- 'cluster'
met <- merge(seuobj@meta.data, object@sample_metadata, by = 0)
rownames(met) <- colnames(seuobj)
seuobj@meta.data <- met
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, latent.vars = latent.vars, ...)
} else {
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, ...)
}
return(results)
}
IBRAP_results <- perform.seurat.diffexp.all(object = FL, assay = 'SCT', test = 'MAST', identity = as.vector(FL@methods$SCT@cluster_assignments$pca_Louvain$RNA_snn_res.0.6), only.pos = F, min.pct = 0.25, return.thresh = 0.05)
#' @name perform.seurat.diffexp.all
#' @aliases perform.seurat.diffexp.all
#'
#' @title Perform differential expression one cluster vs all
#'
#' @description Performs differential expression on the assay differentiating the supplied identities, some methods enable variable regression, including: LR, negbinom, poisson or MAST. This function compares one cluster vs all others
#'
#' @param object An IBRAP class object
#' @param assay Character. Which assay within the IBRAP object to access. Default = NULL
#' @param test Character. Which test to use. Can be either: wilcox, bimod, roc, t, negbinom, poisson, LR, MAST, DESeq2. Please refer to Seurat::FindMarkers for more information.
#' @param identity Vector. A vector of cell identifiers to distinguish cells. Default = NULL
#' @param latent.vars Character. String(s) identifying which variables contained within the metadata to regress from the cells
#' @param ... arguments to pass to Seurat::FindMarkers
#'
#' @return A dataframe containing differentially expression genes and other information
#'
#' @export
#'
perform.seurat.diffexp.all <- function(object,
assay = NULL,
test = 'wilcox',
identity = NULL,
latent.vars = NULL,
...) {
if(!is(object, 'IBRAP')) {
cat(crayon::cyan('Object must be IBRAP class \n'))
return(NULL)
}
if(!is.null(assay)) {
if(!is.character(assay)) {
cat(crayon::cyan('Assay must be character string \n'))
return(NULL)
}
} else if (is.null(assay)) {
cat(crayon::cyan('Please indicate which assay to access \n'))
return(NULL)
}
if(!is.character(test)) {
cat(crayon::cyan('Test must be character string \n'))
return(NULL)
}
if(!is.null(identity)) {
if(!is.vector(identity)) {
cat(crayon::cyan('Identity must be a vector \n'))
return(NULL)
} else if(length(identity) != ncol(object@methods[[assay]]@counts)) {
cat(crayon::cyan('Identity length does not match the number of cells \n'))
return(NULL)
}
} else if (is.null(identity)) {
cat(crayon::cyan('Please provide the cell identities \n'))
return(NULL)
}
if(!is.null(latent.vars)) {
if(!is.character(latent.vars)) {
cat(crayon::cyan('Latent.vars must be character(s)\n'))
return(NULL)
} else if(!latent.vars %in% names(object@sample_metadata)) {
cat(crayon::cyan('Latent.vars do not exist in object@sample_metadata \n'))
return(NULL)
}
seuobj <- Seurat::CreateSeuratObject(counts = object@methods[[assay]]@counts)
seuobj@assays$RNA@data <- object@methods[[assay]]@normalised
seuobj@assays$RNA@scale.data <- object@methods[[assay]]@norm.scaled
seuobj$cluster <- identity
Seurat::Idents(seuobj) <- 'cluster'
met <- merge(seuobj@meta.data, object@sample_metadata, by = 0)
rownames(met) <- colnames(seuobj)
seuobj@meta.data <- met
seuobj
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, latent.vars = latent.vars, ...)
} else {
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, ...)
}
return(results)
}
IBRAP_results <- perform.seurat.diffexp.all(object = FL, assay = 'SCT', test = 'MAST', identity = as.vector(FL@methods$SCT@cluster_assignments$pca_Louvain$RNA_snn_res.0.6), only.pos = F, min.pct = 0.25, return.thresh = 0.05)
#' @name perform.seurat.diffexp.all
#' @aliases perform.seurat.diffexp.all
#'
#' @title Perform differential expression one cluster vs all
#'
#' @description Performs differential expression on the assay differentiating the supplied identities, some methods enable variable regression, including: LR, negbinom, poisson or MAST. This function compares one cluster vs all others
#'
#' @param object An IBRAP class object
#' @param assay Character. Which assay within the IBRAP object to access. Default = NULL
#' @param test Character. Which test to use. Can be either: wilcox, bimod, roc, t, negbinom, poisson, LR, MAST, DESeq2. Please refer to Seurat::FindMarkers for more information.
#' @param identity Vector. A vector of cell identifiers to distinguish cells. Default = NULL
#' @param latent.vars Character. String(s) identifying which variables contained within the metadata to regress from the cells
#' @param ... arguments to pass to Seurat::FindMarkers
#'
#' @return A dataframe containing differentially expression genes and other information
#'
#' @export
#'
perform.seurat.diffexp.all <- function(object,
assay = NULL,
test = 'wilcox',
identity = NULL,
latent.vars = NULL,
...) {
if(!is(object, 'IBRAP')) {
cat(crayon::cyan('Object must be IBRAP class \n'))
return(NULL)
}
if(!is.null(assay)) {
if(!is.character(assay)) {
cat(crayon::cyan('Assay must be character string \n'))
return(NULL)
}
} else if (is.null(assay)) {
cat(crayon::cyan('Please indicate which assay to access \n'))
return(NULL)
}
if(!is.character(test)) {
cat(crayon::cyan('Test must be character string \n'))
return(NULL)
}
if(!is.null(identity)) {
if(!is.vector(identity)) {
cat(crayon::cyan('Identity must be a vector \n'))
return(NULL)
} else if(length(identity) != ncol(object@methods[[assay]]@counts)) {
cat(crayon::cyan('Identity length does not match the number of cells \n'))
return(NULL)
}
} else if (is.null(identity)) {
cat(crayon::cyan('Please provide the cell identities \n'))
return(NULL)
}
if(!is.null(latent.vars)) {
if(!is.character(latent.vars)) {
cat(crayon::cyan('Latent.vars must be character(s)\n'))
return(NULL)
} else if(!latent.vars %in% names(object@sample_metadata)) {
cat(crayon::cyan('Latent.vars do not exist in object@sample_metadata \n'))
return(NULL)
}
seuobj <- Seurat::CreateSeuratObject(counts = object@methods[[assay]]@counts)
seuobj@assays$RNA@data <- object@methods[[assay]]@normalised
seuobj@assays$RNA@scale.data <- object@methods[[assay]]@norm.scaled
seuobj$cluster <- identity
Seurat::Idents(seuobj) <- 'cluster'
met <- merge(seuobj@meta.data, object@sample_metadata, by = 0)
rownames(met) <- colnames(seuobj)
seuobj@meta.data <- met
print(seuobj)
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, latent.vars = latent.vars, ...)
} else {
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, ...)
}
return(results)
}
IBRAP_results <- perform.seurat.diffexp.all(object = FL, assay = 'SCT', test = 'MAST', identity = as.vector(FL@methods$SCT@cluster_assignments$pca_Louvain$RNA_snn_res.0.6), only.pos = F, min.pct = 0.25, return.thresh = 0.05)
#' @name perform.seurat.diffexp.all
#' @aliases perform.seurat.diffexp.all
#'
#' @title Perform differential expression one cluster vs all
#'
#' @description Performs differential expression on the assay differentiating the supplied identities, some methods enable variable regression, including: LR, negbinom, poisson or MAST. This function compares one cluster vs all others
#'
#' @param object An IBRAP class object
#' @param assay Character. Which assay within the IBRAP object to access. Default = NULL
#' @param test Character. Which test to use. Can be either: wilcox, bimod, roc, t, negbinom, poisson, LR, MAST, DESeq2. Please refer to Seurat::FindMarkers for more information.
#' @param identity Vector. A vector of cell identifiers to distinguish cells. Default = NULL
#' @param latent.vars Character. String(s) identifying which variables contained within the metadata to regress from the cells
#' @param ... arguments to pass to Seurat::FindMarkers
#'
#' @return A dataframe containing differentially expression genes and other information
#'
#' @export
#'
perform.seurat.diffexp.all <- function(object,
assay = NULL,
test = 'wilcox',
identity = NULL,
latent.vars = NULL,
...) {
if(!is(object, 'IBRAP')) {
cat(crayon::cyan('Object must be IBRAP class \n'))
return(NULL)
}
if(!is.null(assay)) {
if(!is.character(assay)) {
cat(crayon::cyan('Assay must be character string \n'))
return(NULL)
}
} else if (is.null(assay)) {
cat(crayon::cyan('Please indicate which assay to access \n'))
return(NULL)
}
if(!is.character(test)) {
cat(crayon::cyan('Test must be character string \n'))
return(NULL)
}
if(!is.null(identity)) {
if(!is.vector(identity)) {
cat(crayon::cyan('Identity must be a vector \n'))
return(NULL)
} else if(length(identity) != ncol(object@methods[[assay]]@counts)) {
cat(crayon::cyan('Identity length does not match the number of cells \n'))
return(NULL)
}
} else if (is.null(identity)) {
cat(crayon::cyan('Please provide the cell identities \n'))
return(NULL)
}
if(!is.null(latent.vars)) {
if(!is.character(latent.vars)) {
cat(crayon::cyan('Latent.vars must be character(s)\n'))
return(NULL)
} else if(!latent.vars %in% names(object@sample_metadata)) {
cat(crayon::cyan('Latent.vars do not exist in object@sample_metadata \n'))
return(NULL)
}
seuobj <- Seurat::CreateSeuratObject(counts = object@methods[[assay]]@counts)
seuobj@assays$RNA@data <- object@methods[[assay]]@normalised
seuobj@assays$RNA@scale.data <- object@methods[[assay]]@norm.scaled
seuobj$cluster <- identity
Seurat::Idents(seuobj) <- 'cluster'
met <- merge(seuobj@meta.data, object@sample_metadata, by = 0)
rownames(met) <- colnames(seuobj)
seuobj@meta.data <- met
print('.')
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, latent.vars = latent.vars, ...)
} else {
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, ...)
}
return(results)
}
IBRAP_results <- perform.seurat.diffexp.all(object = FL, assay = 'SCT', test = 'MAST', identity = as.vector(FL@methods$SCT@cluster_assignments$pca_Louvain$RNA_snn_res.0.6), only.pos = F, min.pct = 0.25, return.thresh = 0.05)
detach("package:IBRAP", unload = TRUE)
#' @name perform.seurat.diffexp.all
#' @aliases perform.seurat.diffexp.all
#'
#' @title Perform differential expression one cluster vs all
#'
#' @description Performs differential expression on the assay differentiating the supplied identities, some methods enable variable regression, including: LR, negbinom, poisson or MAST. This function compares one cluster vs all others
#'
#' @param object An IBRAP class object
#' @param assay Character. Which assay within the IBRAP object to access. Default = NULL
#' @param test Character. Which test to use. Can be either: wilcox, bimod, roc, t, negbinom, poisson, LR, MAST, DESeq2. Please refer to Seurat::FindMarkers for more information.
#' @param identity Vector. A vector of cell identifiers to distinguish cells. Default = NULL
#' @param latent.vars Character. String(s) identifying which variables contained within the metadata to regress from the cells
#' @param ... arguments to pass to Seurat::FindMarkers
#'
#' @return A dataframe containing differentially expression genes and other information
#'
#' @export
#'
perform.seurat.diffexp.all <- function(object,
assay = NULL,
test = 'wilcox',
identity = NULL,
latent.vars = NULL,
...) {
if(!is(object, 'IBRAP')) {
cat(crayon::cyan('Object must be IBRAP class \n'))
return(NULL)
}
if(!is.null(assay)) {
if(!is.character(assay)) {
cat(crayon::cyan('Assay must be character string \n'))
return(NULL)
}
} else if (is.null(assay)) {
cat(crayon::cyan('Please indicate which assay to access \n'))
return(NULL)
}
if(!is.character(test)) {
cat(crayon::cyan('Test must be character string \n'))
return(NULL)
}
if(!is.null(identity)) {
if(!is.vector(identity)) {
cat(crayon::cyan('Identity must be a vector \n'))
return(NULL)
} else if(length(identity) != ncol(object@methods[[assay]]@counts)) {
cat(crayon::cyan('Identity length does not match the number of cells \n'))
return(NULL)
}
} else if (is.null(identity)) {
cat(crayon::cyan('Please provide the cell identities \n'))
return(NULL)
}
if(!is.null(latent.vars)) {
if(!is.character(latent.vars)) {
cat(crayon::cyan('Latent.vars must be character(s)\n'))
return(NULL)
} else if(!latent.vars %in% names(object@sample_metadata)) {
cat(crayon::cyan('Latent.vars do not exist in object@sample_metadata \n'))
return(NULL)
}
seuobj <- Seurat::CreateSeuratObject(counts = object@methods[[assay]]@counts)
seuobj@assays$RNA@data <- object@methods[[assay]]@normalised
seuobj@assays$RNA@scale.data <- object@methods[[assay]]@norm.scaled
seuobj$cluster <- identity
Seurat::Idents(seuobj) <- 'cluster'
met <- merge(seuobj@meta.data, object@sample_metadata, by = 0)
rownames(met) <- colnames(seuobj)
seuobj@meta.data <- met
print('.')
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, latent.vars = latent.vars, ...)
} else {
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, ...)
}
return(results)
}
IBRAP_results <- perform.seurat.diffexp.all(object = FL, assay = 'SCT', test = 'MAST', identity = as.vector(FL@methods$SCT@cluster_assignments$pca_Louvain$RNA_snn_res.0.6), only.pos = F, min.pct = 0.25, return.thresh = 0.05)
detach("package:IBRAP", unload = TRUE)
#DEA
all_markers <- FindAllMarkers(object = SeuratObj,only.pos = F,min.pct = 0.25, test.use = "MAST", return.thresh = 0.05)
#' @name perform.seurat.diffexp.all
#' @aliases perform.seurat.diffexp.all
#'
#' @title Perform differential expression one cluster vs all
#'
#' @description Performs differential expression on the assay differentiating the supplied identities, some methods enable variable regression, including: LR, negbinom, poisson or MAST. This function compares one cluster vs all others
#'
#' @param object An IBRAP class object
#' @param assay Character. Which assay within the IBRAP object to access. Default = NULL
#' @param test Character. Which test to use. Can be either: wilcox, bimod, roc, t, negbinom, poisson, LR, MAST, DESeq2. Please refer to Seurat::FindMarkers for more information.
#' @param identity Vector. A vector of cell identifiers to distinguish cells. Default = NULL
#' @param latent.vars Character. String(s) identifying which variables contained within the metadata to regress from the cells
#' @param ... arguments to pass to Seurat::FindMarkers
#'
#' @return A dataframe containing differentially expression genes and other information
#'
#' @export
#'
perform.seurat.diffexp.all <- function(object,
assay = NULL,
test = 'wilcox',
identity = NULL,
latent.vars = NULL,
...) {
if(!is(object, 'IBRAP')) {
cat(crayon::cyan('Object must be IBRAP class \n'))
return(NULL)
}
if(!is.null(assay)) {
if(!is.character(assay)) {
cat(crayon::cyan('Assay must be character string \n'))
return(NULL)
}
} else if (is.null(assay)) {
cat(crayon::cyan('Please indicate which assay to access \n'))
return(NULL)
}
if(!is.character(test)) {
cat(crayon::cyan('Test must be character string \n'))
return(NULL)
}
if(!is.null(identity)) {
if(!is.vector(identity)) {
cat(crayon::cyan('Identity must be a vector \n'))
return(NULL)
} else if(length(identity) != ncol(object@methods[[assay]]@counts)) {
cat(crayon::cyan('Identity length does not match the number of cells \n'))
return(NULL)
}
} else if (is.null(identity)) {
cat(crayon::cyan('Please provide the cell identities \n'))
return(NULL)
}
if(!is.null(latent.vars)) {
if(!is.character(latent.vars)) {
cat(crayon::cyan('Latent.vars must be character(s)\n'))
return(NULL)
} else if(!latent.vars %in% names(object@sample_metadata)) {
cat(crayon::cyan('Latent.vars do not exist in object@sample_metadata \n'))
return(NULL)
}
seuobj <- Seurat::CreateSeuratObject(counts = object@methods[[assay]]@counts)
seuobj@assays$RNA@data <- object@methods[[assay]]@normalised
seuobj@assays$RNA@scale.data <- object@methods[[assay]]@norm.scaled
seuobj$cluster <- identity
Seurat::Idents(seuobj) <- 'cluster'
met <- merge(seuobj@meta.data, object@sample_metadata, by = 0)
rownames(met) <- colnames(seuobj)
seuobj@meta.data <- met
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, latent.vars = latent.vars, ...)
} else {
seuobj <- Seurat::CreateSeuratObject(counts = object@methods[[assay]]@counts)
seuobj@assays$RNA@data <- object@methods[[assay]]@normalised
seuobj@assays$RNA@scale.data <- object@methods[[assay]]@norm.scaled
seuobj$cluster <- identity
Seurat::Idents(seuobj) <- 'cluster'
met <- merge(seuobj@meta.data, object@sample_metadata, by = 0)
rownames(met) <- colnames(seuobj)
seuobj@meta.data <- met
results <- Seurat::FindAllMarkers(object = seuobj, test.use = test, ...)
}
return(results)
}
IBRAP_results <- perform.seurat.diffexp.all(object = FL, assay = 'SCT', test = 'MAST', identity = as.vector(FL@methods$SCT@cluster_assignments$pca_Louvain$RNA_snn_res.0.6), only.pos = F, min.pct = 0.25, return.thresh = 0.05)
IBRAP_results
View(IBRAP_results)
View(all_markers)
fp<- c("CD3E", "CD3D", "CD3G","CD79A","CD79B", "CD8A")
FeaturePlot(object = SeuratObj, features = fp, pt.size = 1.2, reduction = 'umap',min.cutoff = "q10", max.cutoff = "q90", order = TRUE)
fp <- c("CD19", "MS4A1","IGL","IGK","IGHA","KMT2D")
FeaturePlot(object = SeuratObj, features = fp, pt.size = 1.2, reduction = 'umap',min.cutoff = "q10", max.cutoff = "q90", order = TRUE)
FeaturePlot(object = SeuratObj, features = c('CD79A', 'CD79B'), pt.size = 1.2, reduction = 'umap',min.cutoff = "q10", max.cutoff = "q90", order = TRUE)
plot.features.multiple <- function(object,
assay,
slot,
reduction,
features) {
plot.list <- list()
for(x in features) {
print('1')
results <- as.data.frame(object@methods[[assay]]@visualisation_reductions[[reduction]])[,1:2]
orig.colnames <- colnames(object@methods[[assay]]@visualisation_reductions[[reduction]][,1:2])
print('2')
print(assay)
iso <- object@methods[[assay]][[slot]][x,]
print('3')
colnames(results) <- c('red_1', 'red_2')
print('4')
results[,x] <- iso
print('5')
colnames(results)[3] <- 'feature'
print('6')
plot.list[[x]] <- ggplot(data = results[order(results$feature),], aes(x = red_1, y = red_2)) +
geom_point(aes(color=feature)) +
scale_color_gradient(low = '#FFFF00', high = '#FF0000') +
theme_bw() + labs(title=x, x=orig.colnames[1], y=orig.colnames[2]) +
theme(plot.title = element_text(hjust = 0.5, face = 'bold', size = 10))
print('7')
}
is.even <- function(x) {
if(as.integer(x %% 2) == 0) {
print(TRUE)
} else {
print(FALSE)
}
}
if(!is.even(length(plot.list))) {
plot.list[length(plot.list)+1] <- plot.list[1] + geom_blank()
}
if(length(plot.list) > 1){
print('multi')
if(length(plot.list) <3) {
print('1x2')
do.call('ggarrange', c(plots = plot.list, ncol = 1, nrow = 2))
} else if(length(plot.list) <5) {
print('2x2')
do.call('ggarrange', c(plots = plot.list, ncol = 2, nrow = 2))
} else if(length(plot.list) <7) {
print('3x2')
do.call('ggarrange', c(plots = plot.list, ncol = 3, nrow = 2))
}
} else {
print('single')
plot.list[1]
}
}
plot.features.multiple(object = FL, assay = 'SCT', slot = 'normalised', reduction = 'pca_umap', features = fp)
library(ggplot2)
plot.features.multiple(object = FL, assay = 'SCT', slot = 'normalised', reduction = 'pca_umap', features = fp)
fp <- c("CD19", "MS4A1","IGL","IGK","KMT2D")
plot.features.multiple(object = FL, assay = 'SCT', slot = 'normalised', reduction = 'pca_umap', features = fp)
library(egg)
plot.features.multiple(object = FL, assay = 'SCT', slot = 'normalised', reduction = 'pca_umap', features = fp)
plot.features.multiple(object = FL, assay = 'SCT', slot = 'normalised', reduction = 'pca_umap', features = fp)
plot.features.multiple(object = FL, assay = 'SCT', slot = 'normalised', reduction = 'pca_umap', features = c('BIRC5', 'TOP2A', 'MKI67'))
FeaturePlot(object = SeuratObj, features = c('BIRC5', 'TOP2A', 'MKI67'), pt.size = 1.2, reduction = 'umap',min.cutoff = "q10", max.cutoff = "q90", order = TRUE)
FeaturePlot(object = SeuratObj, features = c('BIRC5', 'TOP2A', 'MKI67'), pt.size = 1.2, reduction = 'umap', order = TRUE)
GO_res <- perform.GO.enrichment(result = IBRAP_results)
GO_res
#' @name plot.GO.output
#' @aliases plot.GO.output
#'
#' @title Plot GO enrichment output
#'
#' @description Creates a dot plot of GO terms
#'
#' @param result The result file from the perform.GO.enrichment
#'
#' @return IBRAP S4 class object containing raw counts and metadata
#'
#' @export
plot.GO.output <- function(result) {
result$rank <- -log10(result$rank)
result$cluster <- as.character(result$cluster)
ggplot2::ggplot(data = result, ggplot2::aes(y = Term, x = cluster, color = rank)) +
ggplot2::geom_point(ggplot2::aes(size = rank)) + ggplot2::scale_size_continuous() +
ggplot2::theme_bw() + ggplot2::guides(color=ggplot2::guide_legend(title="-log10(rank)"), size=ggplot2::guide_legend(title="-log10(rank)"))
}
plot.GO.output(result = GO_res)
