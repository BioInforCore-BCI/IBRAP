goEnrichment[,'cluster'] <- x
if(is.numeric(x)) {
x <- x + 1
}
GO_outputs[[x]] <- goEnrichment
print('success')
}
}
print(length(GO_outputs))
cat_df <- GO_outputs[[1]]
for(x in 2:length(GO_outputs)) {
cat_df <- merge(cat_df, GO_outputs[[x]], all = T)
print(x)
print(cat_df)
}
return(cat_df)
}
#' @name perform.GO.enrichment
#' @aliases perform.GO.enrichment
#'
#' @title Gene Ontology enrichment
#'
#' @description Performs gene ontology enrichment for individual cluster differential expression results.
#'
#' @param result A database containing the differential expression results
#' @param whichOnto Character. specifying one of the three GO ontologies, namely: "BP", "MF", "CC". Default = 'BP'
#' @param feasibleGenes Character vector. vector containing a subset of gene identifiers. Only these genes will be used to annotate GO terms. Default value is NULL which means that there are no genes filtered.
#' @param mapping Character. The name of the Bioconductor package containing the gene mappings for a specific organism. For example: mapping = "org.Hs.eg.db".
#' @param ID Character. Specify the gene identifier to use. Currently only the following identifiers can be used: c("entrez", "genbank", "alias", "ensembl", "symbol", "genename", "unigene")
#' @param nodeSize Numerical. Minimum number of genes required to consider a GO term. Default = 5
#' @param statistic Character. Which statistic to use when testing for significant GO terms, options: 'fisher', 'ks', 't', 'globaltest', 'sum', 'ks.ties'. Default = 'ks'
#' @param algorithm Character. Which algorithm to use when testing for significant GO terms, options: 'classic', 'elim', 'weight', 'weight01', 'lea', 'parentchild'. Default = 'classic'
#' @param rank.cutoff Numerical. Which cut off to apply for pathway significance, this value will change according to the statistic applied. Default = 0.001
#' @param gene.col Character. Which column name within differential expression results contains the genes. Default = 'gene.col'
#' @param pval.col Character. Which column name within differential expression results contains the p values. Default = 'p_val'
#' @param cluster.col Character. Which column name within differential expression results contains the cluster assignments. Default = 'cluster'
#' @param n.top.pathways Numerical. How many top pathways per group should be retained. Default = 10
#'
#' @return A dataframe containing the top enriched pathways for each cluster
#'
#' @export
#'
perform.GO.enrichment <- function(result,
whichOnto = 'BP',
feasibleGenes = NULL,
mapping = 'org.Hs.eg.db',
ID = 'symbol',
nodeSize = 5,
algorithm = 'classic',
statistic = 'ks',
rank.cutoff = 0.001,
gene.col = 'gene',
pval.col = 'p_val',
cluster.col = 'cluster',
n.top.pathways = 10) {
if(!is.data.frame(result)) {
cat(crayon::cyan('results must be in data.frame format \n'))
return(NULL)
}
if(!is.character(gene.col)) {
cat(crayon::cyan('Gene.col must be a character string \n'))
return(NULL)
} else if (!gene.col %in% colnames(result)) {
cat(crayon::cyan('gene.col is not in colnames(results) \n'))
return(NULL)
}
if(!is.character(pval.col)) {
cat(crayon::cyan('pval.col must be a character string \n'))
return(NULL)
} else if (!pval.col %in% colnames(result)) {
cat(crayon::cyan('pval.col is not in colnames(results) \n'))
return(NULL)
}
if(!is.character(cluster.col)) {
cat(crayon::cyan('cluster.col must be a character string \n'))
return(NULL)
} else if (!cluster.col %in% colnames(result)) {
cat(crayon::cyan('cluster.col is not in colnames(results) \n'))
return(NULL)
}
if(!is.numeric(nodeSize)) {
cat(crayon::cyan('nodeSize must be numerical\n'))
return(NULL)
}
if(!is.numeric(rank.cutoff)) {
cat(crayon::cyan('rank.cutoff must be numerical\n'))
return(NULL)
}
if(!is.numeric(n.top.pathways)) {
cat(crayon::cyan('n.top.pathways must be numerical\n'))
return(NULL)
}
require(topGO)
selection <- function(x) TRUE
allGO2genes <- topGO::annFUN.org(whichOnto=whichOnto, feasibleGenes=feasibleGenes, mapping=mapping, ID=ID)
GO_outputs <- list()
for(x in unique(result[,cluster.col])) {
cluster_x <- result[result[,cluster.col] == x,]
genes <- setNames(cluster_x[,pval.col], cluster_x[,gene.col])
GOdata <- new("topGOdata", ontology="BP", allGenes=genes,
annot=annFUN.GO2genes, GO2genes=allGO2genes,
geneSel=selection, nodeSize=nodeSize)
results.ks <- runTest(GOdata, algorithm=algorithm, statistic=statistic)
goEnrichment <- GenTable(GOdata, rank=results.ks, topNodes=n.top.pathways)
temp <- goEnrichment$rank
for(t in 1:length(temp)) {
if(stringr::str_detect(string = temp[t], pattern = '< ')) {
temp[t] <- strsplit(x = temp[t], split = ' ')[[1]][2]
}
}
goEnrichment$rank <- as.numeric(temp)
goEnrichment <- goEnrichment[goEnrichment$rank<rank.cutoff,]
goEnrichment <- goEnrichment[,c("GO.ID","Term","rank")]
print(goEnrichment)
print(class(goEnrichment))
if(nrow(goEnrichment) > 0 || !is.null(goEnrichment)) {
goEnrichment[,'cluster'] <- x
if(is.numeric(x)) {
x <- x + 1
}
GO_outputs[[x]] <- goEnrichment
print('success')
}
}
print(length(GO_outputs))
cat_df <- GO_outputs[[1]]
for(x in 2:length(GO_outputs)) {
cat_df <- merge(cat_df, GO_outputs[[x]], all = T)
print(x)
print(cat_df)
}
return(cat_df)
}
GO_outputs <- list()
for(x in unique(result[,cluster.col])) {
cluster_x <- result[result[,cluster.col] == x,]
genes <- setNames(cluster_x[,pval.col], cluster_x[,gene.col])
GOdata <- new("topGOdata", ontology="BP", allGenes=genes,
annot=annFUN.GO2genes, GO2genes=allGO2genes,
geneSel=selection, nodeSize=nodeSize)
results.ks <- runTest(GOdata, algorithm=algorithm, statistic=statistic)
goEnrichment <- GenTable(GOdata, rank=results.ks, topNodes=n.top.pathways)
temp <- goEnrichment$rank
for(t in 1:length(temp)) {
if(stringr::str_detect(string = temp[t], pattern = '< ')) {
temp[t] <- strsplit(x = temp[t], split = ' ')[[1]][2]
}
}
goEnrichment$rank <- as.numeric(temp)
goEnrichment <- goEnrichment[goEnrichment$rank<rank.cutoff,]
goEnrichment <- goEnrichment[,c("GO.ID","Term","rank")]
print(goEnrichment)
print(class(goEnrichment))
if(nrow(goEnrichment) > 0 || !is.null(goEnrichment)) {
goEnrichment[,'cluster'] <- x
if(is.numeric(x)) {
x <- x + 1
}
GO_outputs[[x]] <- goEnrichment
print('success')
}
}
GO_outputs <- list()
for(x in unique(result[,cluster.col])) {
cluster_x <- result[result[,cluster.col] == x,]
genes <- setNames(cluster_x[,pval.col], cluster_x[,gene.col])
GOdata <- new("topGOdata", ontology="BP", allGenes=genes,
annot=annFUN.GO2genes, GO2genes=allGO2genes,
geneSel=selection, nodeSize=nodeSize)
results.ks <- runTest(GOdata, algorithm=algorithm, statistic=statistic)
goEnrichment <- GenTable(GOdata, rank=results.ks, topNodes=n.top.pathways)
temp <- goEnrichment$rank
for(t in 1:length(temp)) {
if(stringr::str_detect(string = temp[t], pattern = '< ')) {
temp[t] <- strsplit(x = temp[t], split = ' ')[[1]][2]
}
}
goEnrichment$rank <- as.numeric(temp)
goEnrichment <- goEnrichment[goEnrichment$rank<rank.cutoff,]
goEnrichment <- goEnrichment[,c("GO.ID","Term","rank")]
print(goEnrichment)
print(class(goEnrichment))
print(nrow(goEnrichment))
if(nrow(goEnrichment) > 0 || !is.null(goEnrichment)) {
goEnrichment[,'cluster'] <- x
if(is.numeric(x)) {
x <- x + 1
}
GO_outputs[[x]] <- goEnrichment
print('success')
}
}
GO_outputs <- list()
for(x in unique(result[,cluster.col])) {
cluster_x <- result[result[,cluster.col] == x,]
genes <- setNames(cluster_x[,pval.col], cluster_x[,gene.col])
GOdata <- new("topGOdata", ontology="BP", allGenes=genes,
annot=annFUN.GO2genes, GO2genes=allGO2genes,
geneSel=selection, nodeSize=nodeSize)
results.ks <- runTest(GOdata, algorithm=algorithm, statistic=statistic)
goEnrichment <- GenTable(GOdata, rank=results.ks, topNodes=n.top.pathways)
temp <- goEnrichment$rank
for(t in 1:length(temp)) {
if(stringr::str_detect(string = temp[t], pattern = '< ')) {
temp[t] <- strsplit(x = temp[t], split = ' ')[[1]][2]
}
}
goEnrichment$rank <- as.numeric(temp)
goEnrichment <- goEnrichment[goEnrichment$rank<rank.cutoff,]
goEnrichment <- goEnrichment[,c("GO.ID","Term","rank")]
print(goEnrichment)
print(class(goEnrichment))
print(nrow(goEnrichment))
if(nrow(goEnrichment) > 0) {
goEnrichment[,'cluster'] <- x
if(is.numeric(x)) {
x <- x + 1
}
GO_outputs[[x]] <- goEnrichment
print('success')
}
}
GO_outputs[[1]]
GO_outputs[[2]]
GO_outputs[[3]]
GO_outputs[[4]]
GO_outputs[[10]]
GO_outputs[[11]]
GO_outputs[[12]]
GO_outputs[[13]]
cat_df <- GO_outputs[[1]]
for(x in 2:length(GO_outputs)) {
if(!is.null(GO_outputs[[x]])) {
cat_df <- merge(cat_df, GO_outputs[[x]], all = T)
print(x)
print(cat_df)
}
}
cat_df
#' @name perform.GO.enrichment
#' @aliases perform.GO.enrichment
#'
#' @title Gene Ontology enrichment
#'
#' @description Performs gene ontology enrichment for individual cluster differential expression results.
#'
#' @param result A database containing the differential expression results
#' @param whichOnto Character. specifying one of the three GO ontologies, namely: "BP", "MF", "CC". Default = 'BP'
#' @param feasibleGenes Character vector. vector containing a subset of gene identifiers. Only these genes will be used to annotate GO terms. Default value is NULL which means that there are no genes filtered.
#' @param mapping Character. The name of the Bioconductor package containing the gene mappings for a specific organism. For example: mapping = "org.Hs.eg.db".
#' @param ID Character. Specify the gene identifier to use. Currently only the following identifiers can be used: c("entrez", "genbank", "alias", "ensembl", "symbol", "genename", "unigene")
#' @param nodeSize Numerical. Minimum number of genes required to consider a GO term. Default = 5
#' @param statistic Character. Which statistic to use when testing for significant GO terms, options: 'fisher', 'ks', 't', 'globaltest', 'sum', 'ks.ties'. Default = 'ks'
#' @param algorithm Character. Which algorithm to use when testing for significant GO terms, options: 'classic', 'elim', 'weight', 'weight01', 'lea', 'parentchild'. Default = 'classic'
#' @param rank.cutoff Numerical. Which cut off to apply for pathway significance, this value will change according to the statistic applied. Default = 0.001
#' @param gene.col Character. Which column name within differential expression results contains the genes. Default = 'gene.col'
#' @param pval.col Character. Which column name within differential expression results contains the p values. Default = 'p_val'
#' @param cluster.col Character. Which column name within differential expression results contains the cluster assignments. Default = 'cluster'
#' @param n.top.pathways Numerical. How many top pathways per group should be retained. Default = 10
#'
#' @return A dataframe containing the top enriched pathways for each cluster
#'
#' @export
#'
perform.GO.enrichment <- function(result,
whichOnto = 'BP',
feasibleGenes = NULL,
mapping = 'org.Hs.eg.db',
ID = 'symbol',
nodeSize = 5,
algorithm = 'classic',
statistic = 'ks',
rank.cutoff = 0.001,
gene.col = 'gene',
pval.col = 'p_val',
cluster.col = 'cluster',
n.top.pathways = 10) {
if(!is.data.frame(result)) {
cat(crayon::cyan('results must be in data.frame format \n'))
return(NULL)
}
if(!is.character(gene.col)) {
cat(crayon::cyan('Gene.col must be a character string \n'))
return(NULL)
} else if (!gene.col %in% colnames(result)) {
cat(crayon::cyan('gene.col is not in colnames(results) \n'))
return(NULL)
}
if(!is.character(pval.col)) {
cat(crayon::cyan('pval.col must be a character string \n'))
return(NULL)
} else if (!pval.col %in% colnames(result)) {
cat(crayon::cyan('pval.col is not in colnames(results) \n'))
return(NULL)
}
if(!is.character(cluster.col)) {
cat(crayon::cyan('cluster.col must be a character string \n'))
return(NULL)
} else if (!cluster.col %in% colnames(result)) {
cat(crayon::cyan('cluster.col is not in colnames(results) \n'))
return(NULL)
}
if(!is.numeric(nodeSize)) {
cat(crayon::cyan('nodeSize must be numerical\n'))
return(NULL)
}
if(!is.numeric(rank.cutoff)) {
cat(crayon::cyan('rank.cutoff must be numerical\n'))
return(NULL)
}
if(!is.numeric(n.top.pathways)) {
cat(crayon::cyan('n.top.pathways must be numerical\n'))
return(NULL)
}
require(topGO)
selection <- function(x) TRUE
allGO2genes <- topGO::annFUN.org(whichOnto=whichOnto, feasibleGenes=feasibleGenes, mapping=mapping, ID=ID)
GO_outputs <- list()
for(x in unique(result[,cluster.col])) {
cluster_x <- result[result[,cluster.col] == x,]
genes <- setNames(cluster_x[,pval.col], cluster_x[,gene.col])
GOdata <- new("topGOdata", ontology="BP", allGenes=genes,
annot=annFUN.GO2genes, GO2genes=allGO2genes,
geneSel=selection, nodeSize=nodeSize)
results.ks <- runTest(GOdata, algorithm=algorithm, statistic=statistic)
goEnrichment <- GenTable(GOdata, rank=results.ks, topNodes=n.top.pathways)
temp <- goEnrichment$rank
for(t in 1:length(temp)) {
if(stringr::str_detect(string = temp[t], pattern = '< ')) {
temp[t] <- strsplit(x = temp[t], split = ' ')[[1]][2]
}
}
goEnrichment$rank <- as.numeric(temp)
goEnrichment <- goEnrichment[goEnrichment$rank<rank.cutoff,]
goEnrichment <- goEnrichment[,c("GO.ID","Term","rank")]
if(nrow(goEnrichment) > 0) {
goEnrichment[,'cluster'] <- x
if(is.numeric(x)) {
x <- x + 1
}
GO_outputs[[x]] <- goEnrichment
}
}
cat_df <- GO_outputs[[1]]
for(x in 2:length(GO_outputs)) {
if(!is.null(GO_outputs[[x]])) {
cat_df <- merge(cat_df, GO_outputs[[x]], all = T)
}
}
return(cat_df)
}
GO_res <- perform.GO.enrichment(result = DE_res)
GO_res
plot.GO.output <- function(result) {
result$rank <- -log10(result$rank)
result$cluster <- as.character(result$cluster)
ggplot2::ggplot(data = result, ggplot2::aes(y = Term, x = cluster, color = rank)) +
ggplot2::geom_point(ggplot2::aes(size = rank)) + ggplot2::scale_size_continuous() +
ggplot2::theme_bw() + ggplot2::guides(color=ggplot2::guide_legend(title="-log10(rank)"), size=ggplot2::guide_legend(title="-log10(rank)"))
}
plot.GO.output(result = )
plot.GO.output(result = GO_res)
rm(perform.GO.enrichment, perform.singleR.annotation, plot.GO.output, selection)
roxygen2::roxygenise()
#' @name perform.seurat.diffexp
#' @aliases perform.seurat.diffexp
#'
#' @title Perform differential expression
#'
#' @description Performs differential expression on the assay differentiating the supplied identities, some methods enable variable regression, including: LR, negbinom, poisson or MAST. This function compares one cluster vs all others
#'
#' @param object An IBRAP class object
#' @param assay Character. Which assay within the IBRAP object to access. Default = NULL
#' @param test Character. Which test to use. Can be either: wilcox, bimod, roc, t, negbinom, poisson, LR, MAST, DESeq2. Please refer to Seurat::FindMarkers for more information.
#' @param identity Vector. A vector of cell identifiers to distinguish cells. Default = NULL
#' @param latent.vars Character. String(s) identifying which variables contained within the metadata to regress from the cells
#' @param ... arguments to pass to Seurat::FindMarkers
#'
#' @return A dataframe containing differentially expression genes and other information
#'
#' @export
#'
perform.seurat.diffexp <- function(object,
assay = NULL,
test = 'wilcox',
identity = NULL,
ident.1 = NULL,
ident.2 = NULL,
cells.1 = NULL,
cells.2 = NULL,
latent.vars = NULL,
...) {
if(!is(object, 'IBRAP')) {
cat(crayon::cyan('Object must be IBRAP class \n'))
return(NULL)
}
if(!is.null(assay)) {
if(!is.character(assay)) {
cat(crayon::cyan('Assay must be character string \n'))
return(NULL)
}
} else if (is.null(assay)) {
cat(crayon::cyan('Please indicate which assay to access \n'))
return(NULL)
}
if(!is.character(test)) {
cat(crayon::cyan('Test must be character string \n'))
return(NULL)
}
if(!is.null(cells.1)) {
if(!is.vector(cells.1)) {
cat(crayon::cyan('cells.1 must be a vector \n'))
return(NULL)
} else if(!cells.1 %in% colnames(object@methods[[assay]][[counts]] )) {
cat(crayon::cyan('cells.1 are not contained within the assay \n'))
return(NULL)
}
} else if (is.null(cells.1)) {
cat(crayon::cyan('Please provide the cells.1 identities \n'))
return(NULL)
}
if(!is.null(cells.2)) {
if(!is.vector(cells.2)) {
cat(crayon::cyan('cells.2 must be a vector \n'))
return(NULL)
} else if(!cells.2 %in% colnames(object@methods[[assay]][[counts]] )) {
cat(crayon::cyan('cells.2 are not contained within the assay \n'))
return(NULL)
}
} else if (is.null(cells.2)) {
cat(crayon::cyan('Please provide the cells.2 identities \n'))
return(NULL)
}
seuobj <- Seurat::CreateSeuratObject(counts = object@methods[[assay]]@counts)
seuobj@assays$RNA@data <- object@methods[[assay]]@normalised
seuobj@assays$RNA@scale.data <- object@methods[[assay]]@norm.scaled
if(!is.null(identity)) {
if(!is.vector(identity)) {
cat(crayon::cyan('Identity must be a vector \n'))
return(NULL)
} else if(length(identity) != ncol(object@methods[[assay]]@counts)) {
cat(crayon::cyan('Identity length does not match the number of cells \n'))
return(NULL)
}
} else if (is.null(identity)) {
cat(crayon::cyan('Please provide the cell identities \n'))
return(NULL)
}
if(!is.null(ident.1) && !is.null(identity)) {
if(!is.vector(ident.1)) {
cat(crayon::cyan('ident.1 must be a vector \n'))
return(NULL)
} else if (!ident.1 %in% identity) {
cat(crayon::cyan('ident.1 is not contained within identity \n'))
return(NULL)
} else {
seuobj$clusters <- identity
Seurat::Idents(seuobj) <- 'clusters'
}
}
if(!is.null(ident.2) && !is.null(identity)) {
if(!is.vector(ident.2)) {
cat(crayon::cyan('ident.2 must be a vector \n'))
return(NULL)
} else if (!ident.2 %in% identity) {
cat(crayon::cyan('ident.2 is not contained within identity \n'))
return(NULL)
}
}
if(!is.null(latent.vars)) {
if(!is.character(latent.vars)) {
cat(crayon::cyan('Latent.vars must be character(s)\n'))
return(NULL)
} if (!latent.vars %in% names(object@sample_metadata)) {
cat(crayon::cyan('Latent.vars do not exist in object@sample_metadata \n'))
return(NULL)
}
met <- merge(seuobj@meta.data, object@sample_metadata, by = 0)
rownames(met) <- colnames(seuobj)
seuobj@meta.data <- met
if(!is.null(identity) && !is.null(ident.1) && !is.null(ident.2)) {
results <- Seurat::FindMarkers(object = seuobj, ident.1 = ident.1, ident.2 = ident.2,  test.use = test, latent.vars = latent.vars, ...)
} else if (!is.null(cells.1) && !is.null(cells.2)) {
results <- Seurat::FindMarkers(object = seuobj, cells.1 = cells.1, cells.2 = cells.2,  test.use = test, latent.vars = latent.vars, ...)
}
} else {
if(!is.null(identity) && !is.null(ident.1) && !is.null(ident.2)) {
results <- Seurat::FindMarkers(object = seuobj, ident.1 = ident.1, ident.2 = ident.2,  test.use = test, ...)
} else if (!is.null(cells.1) && !is.null(cells.2)) {
results <- Seurat::FindMarkers(object = seuobj, cells.1 = cells.1, cells.2 = cells.2,  test.use = test, ...)
}
}
return(results)
}
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::install_github(repo = 'connorhknight/IBRAP')
library(IBRAP)
roxygen2::roxygenise()
devtools::install_github(repo = 'connorhknight/IBRAP')
library(IBRAP)
panc_res <- perform.seurat.diffexp.all(object = pancreas, assay = 'SCT', identity = pancreas@sample_metadata$celltype, latent.vars = 'original.project')
roxygen2::roxygenise()
devtools::install_github(repo = 'connorhknight/IBRAP')
library(IBRAP)
panc_res <- perform.seurat.diffexp.all(object = pancreas, assay = 'SCT', identity = pancreas@sample_metadata$celltype, latent.vars = 'original.project')
pancreas@sample_metadata$celltype
roxygen2::roxygenise()
devtools::install_github(repo = 'connorhknight/IBRAP')
devtools::install_github(repo = 'connorhknight/IBRAP')
library(IBRAP)
panc_res <- perform.seurat.diffexp.all(object = pancreas, assay = 'SCT', identity = pancreas@sample_metadata$celltype, latent.vars = 'original.project')
